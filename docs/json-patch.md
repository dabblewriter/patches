<!-- Placeholder for JSON Patch documentation -->

# JSON Patch Implementation

This library includes a comprehensive implementation of JSON Patch (RFC 6902), along with utilities for creating, applying, and manipulating patches. While the library's primary focus is shifting towards Operational Transformation (OT), this JSON Patch functionality remains available.

**Table of Contents**

- [Overview](#overview)
- [`JSONPatch` Class](#jsonpatch-class)
  - [Initialization](#initialization)
  - [Standard Operations](#standard-operations) (`add`, `remove`, `replace`, `move`, `copy`, `test`)
  - [Custom Operations](#custom-operations) (`@inc`, `@bit`, `@txt`)
  - [Utility Methods](#utility-methods) (`addUpdates`, `apply`, `transform`, `invert`, `compose`, `concat`, `toJSON`, `fromJSON`)
- [`createJSONPatch()` Helper](#createjsonpatch-helper)
- [`createPatchProxy()` Utility](#createpatchproxy-utility)
  - [Path Generation Mode](#path-generation-mode)
  - [Automatic Patch Generation Mode](#automatic-patch-generation-mode)
- [`applyPatch()` Function](#applypatch-function)
- [Operation Handlers](#operation-handlers)
- [Patch Utilities: `transformPatch`, `invertPatch`, `composePatch`](#patch-utilities-transformpatch-invertpatch-composepatch)

## Overview

JSON Patch defines a format for describing changes to a JSON document. It uses an array of operation objects, each specifying an operation (like `add`, `remove`, `replace`), a target path (using JSON Pointer syntax), and optionally a value or a source path (`from`).

This library provides:

- A `JSONPatch` class offering a fluent API for building patches.
- Functions like `createJSONPatch` and `createPatchProxy` for generating patches from object modifications.
- An `applyPatch` function to apply patches immutably.
- Support for custom operations beyond the standard RFC 6902 set.
- Implementations for OT functions (`transform`, `invert`, `compose`) tailored for JSON Patch operations.

## `JSONPatch` Class

(`src/json-patch/JSONPatch.ts`)

This class is the main way to work with patches programmatically.

### Initialization

```typescript
import { JSONPatch, JSONPatchOp } from '@dabble/patches';

// Create an empty patch
const patch1 = new JSONPatch();

// Create with initial operations
const initialOps: JSONPatchOp[] = [{ op: 'replace', path: '/name', value: 'Initial' }];
const patch2 = new JSONPatch(initialOps);

// Create with custom operation handlers (see Operation Handlers section)
// const patch3 = new JSONPatch([], { '@myOp': myCustomHandler });
```

### Standard Operations

The class provides methods corresponding to standard JSON Patch operations. These methods generate and append `CompactPatchOp` entries to the internal `ops` array.

- **`test(path: PathLike, value: any): this`**
  Adds a `test` operation. Asserts the value at `path` equals `value`.
  ```typescript
  patch.test('/status', 'active');
  // { op: 'test', path: '/status', value: 'active' }
  ```
- **`add(path: PathLike, value: any, options?: WriteOptions): this`**
  Adds an `add` operation. Adds/inserts `value` at `path`. `add` and `replace` are functionally equivalent except within arrays.
  ```typescript
  patch.add('/tags/-', 'new'); // Append to array
  // { op: 'add', path: '/tags/-', value: 'new' }
  patch.add('/user/profile', { bio: '...' });
  // { op: 'add', path: '/user/profile', value: { bio: '...' } }
  ```
- **`remove(path: PathLike): this`**
  Adds a `remove` operation. Removes the value at `path`.
  ```typescript
  patch.remove('/obsoleteField');
  // { op: 'remove', path: '/obsoleteField' }
  ```
- **`replace(path: PathLike, value: any, options?: WriteOptions): this`**
  Adds a `replace` operation. Replaces the value at `path` with `value`. `add` and `replace` are functionally equivalent except within arrays.
  ```typescript
  patch.replace('/config/timeout', 500);
  // { op: 'replace', path: '/config/timeout', value: 500 }
  ```
- **`copy(from: PathLike, to: PathLike, options?: WriteOptions): this`**
  Adds a `copy` operation. Copies the value from `from` path to `to` path.
  ```typescript
  patch.copy('/user/name', '/backup/userName');
  // { op: 'copy', from: '/user/name', path: '/backup/userName' }
  ```
- **`move(from: PathLike, to: PathLike): this`**
  Adds a `move` operation. Moves the value from `from` to `to`.
  ```typescript
  patch.move('/temporary/data', '/permanent/data');
  // { op: 'move', from: '/temporary/data', path: '/permanent/data' }
  ```

_Note on `PathLike`:_ The `path` and `from` arguments in these methods accept a `PathLike` type, which is defined as `string | { toString(): string }`. This means you can provide either:

- A standard JSON Pointer string (e.g., `'/user/name'`, `'/items/0/id'`). If the string doesn't start with `/`, it will be automatically prefixed.
- An object that has a `toString()` method returning a valid JSON Pointer string. This is primarily used with the type-safe path builder generated by [`createJSONPatch()`](#path-generation-mode) (e.g., `pathProxy.user.name.toString()` results in `'/user/name'`).

_Note on `WriteOptions`:_ The `soft` option can sometimes allow `add`/`replace`/`copy` operations to proceed even if intermediate objects in the path don't exist, potentially avoiding errors in specific backend implementations, but use with caution as it deviates from strict RFC behavior.

### Custom Operations

These provide convenient methods for common custom operations included in the library:

- **`increment(path: PathLike, value: number = 1): this`**
  Adds an `@inc` operation to increment a number..
  ```typescript
  patch.increment('/counter'); // Increment by 1
  patch.increment('/score', 10); // Increment by 10
  // { op: '@inc', path: '/counter', value: 1 }
  // { op: '@inc', path: '/score', value: 10 }
  ```
- **`decrement(path: PathLike, value: number = 1): this`**
  Adds an `@inc` operation with a negative value.
  ```typescript
  patch.decrement('/remaining', 5);
  // { op: '@inc', path: '/remaining', value: -5 }
  ```
- **`bit(path: PathLike, index: number, on: boolean): this`**
  Adds an `@bit` operation for bitmask manipulation (uses `createBitmask` utility). This allows you to toggle specific bits in a bitmask without overwriting the entire mask.
  ```typescript
  patch.bit('/flags', 3, true); // Set 3rd bit ON
  patch.bit('/flags', 0, false); // Set 0th bit OFF
  // { op: '@bit', path: '/flags', value: 8 } // 1 << 3
  // { op: '@bit', path: '/flags', value: 32768 } // 1 << (0 + 15)
  ```
- **`text(path: PathLike, delta: Delta | Op[]): this`**
  Adds an `@txt` operation for applying rich text deltas (requires `@dabble/delta`, `quill-delta`, or similar).
  ```typescript
  // import { Delta } from '@dabble/delta';
  patch.text('/textContent', new Delta().insert('Hello'));
  // { op: '@txt', path: '/textContent', value: { ops: [{ insert: 'Hello'}] } }
  ```

### Utility Methods

- **`addUpdates(updates: { [key: string]: any }, pathPrefix: string = '/'): this`**
  Generates `replace` (for defined values) or `remove` (for `undefined` values) operations for each key-value pair in the `updates` object, applying an optional `pathPrefix`.
  ```typescript
  patch.addUpdates({ title: 'New', status: undefined }, '/doc');
  // { op: 'replace', path: '/doc/title', value: 'New' }
  // { op: 'remove', path: '/doc/status' }
  ```
- **`apply<T>(obj: T, options?: ApplyJSONPatchOptions): { doc: T, errors: any[] }`**
  Applies the patch's operations (`this.ops`) to the given object `obj`. Returns the new state and any errors encountered. See [`applyPatch()`](#applypatch-function).
- **`transform(otherPatch: JSONPatch | JSONPatchOp[], obj?: any): JSONPatch`**
  Transforms another patch against this one, assuming this patch happened first. Requires the original object state `obj` for accuracy. Uses logic from [`transformPatch`](../src/json-patch/transformPatch.ts). Returns a _new_ `JSONPatch` instance with the transformed operations.
- **`invert(obj: any): JSONPatch`**
  Generates an inverse patch. Requires the object state `obj` _before_ this patch was applied. Uses logic from [`invertPatch`](../src/json-patch/invertPatch.ts). Returns a _new_ `JSONPatch` instance.
- **`compose(patch?: JSONPatch | JSONPatchOp[]): JSONPatch`**
  Composes operations within this patch (and optionally another) into a more concise form (e.g., merging consecutive `@inc` ops). Uses logic from [`composePatch`](../src/json-patch/composePatch.ts). Returns a _new_ `JSONPatch` instance.
- **`concat(patch: JSONPatch | JSONPatchOp[]): JSONPatch`**
  Combines the operations from this patch and another into a single new patch. Returns a _new_ `JSONPatch` instance.
- **`toJSON(): JSONPatchOp[]`**
  Returns a copy of the raw array of operations (`this.ops`).
- **`static fromJSON(ops?: JSONPatchOp[], custom?: JSONPatchOpHandlerMap): JSONPatch`**
  Creates a new `JSONPatch` instance from an array of operations.

## Patch Utilities: `transformPatch`, `invertPatch`, `composePatch`

These advanced utilities allow you to manipulate and reason about JSON Patch operation arrays, supporting Operational Transformation (OT) workflows and more. They are used internally by the library and are available for advanced use cases.

### `transformPatch`

([`src/json-patch/transformPatch.ts`](../src/json-patch/transformPatch.ts))

This function takes two sets of operations, `thisOps` (considered to have happened first) and `otherOps` (concurrent), along with the document state _before_ either set was applied. It iterates through `thisOps`, and for each operation, it calls the appropriate `transform` handler to modify `otherOps`.

The goal is to produce a new set of `otherOps` that can be applied _after_ `thisOps` to reach the same final state as if the operations had occurred in a specific server-defined order.

**Note:** The accuracy of transformation heavily depends on the correct implementation of individual operation handlers and providing the correct state context to `transformPatch`. See [Operation Handlers](#operation-handlers) for more details.

### `invertPatch`

([`src/json-patch/invertPatch.ts`](../src/json-patch/invertPatch.ts))

This function generates an inverse patch for a given set of operations, allowing you to undo changes. It requires the object state _before_ the patch was applied. Each operation type must implement an `invert` handler for this to work correctly.

### `composePatch`

([`src/json-patch/composePatch.ts`](../src/json-patch/composePatch.ts))

This function attempts to merge consecutive operations of the same type on the same path into a more concise form (e.g., merging multiple `@inc` operations into one). Each operation type can optionally implement a `compose` handler to define how composition works for that type.

**See also:** [Operation Handlers](#operation-handlers) for how these utilities interact with custom operation logic.

> For more on how these utilities are used in collaborative/OT workflows, see [Operational Transformation](./operational-transformation.md).

## `createJSONPatch()` Helper

(`src/json-patch/createJSONPatch.ts`)

This function provides an Immer-like API for generating patches.

```typescript
import { createJSONPatch } from '@dabble/patches';

const myObj = { user: { name: 'Alice' }, count: 10, items: ['apple'] };

const patch = createJSONPatch(myObj, (draft, p) => {
  // Modify the draft object directly
  draft.user.name = 'Bob';
  draft.items.push('banana');
  delete draft.count;

  // Optionally, call methods on the patch instance `p` for custom ops
  // p.increment(draft.someCounter); // Path needs to be generated correctly
});

// `patch` now contains the generated operations:
// [ { op: 'replace', path: '/user/name', value: 'Bob' },
//   { op: 'add', path: '/items/1', value: 'banana' },
//   { op: 'remove', path: '/count' } ]
```

- It takes the initial `target` object and an `updater` function.
- The `updater` receives a mutable `proxy` (draft) of the target and a `JSONPatch` instance.
- Modifications to the `proxy` (property sets, deletes, array method calls like `push`, `splice`) automatically generate `add`/`remove`/`replace` operations on the `JSONPatch` instance.
- You can also directly use the passed `patch` instance inside the updater.
- Returns the `JSONPatch` instance containing all generated operations.
- Uses [`createPatchProxy()`](#createpatchproxy-utility) internally.

## `createPatchProxy()` Utility

(`src/json-patch/patchProxy.ts`)

This is the underlying mechanism used by `createJSONPatch`. It can be used directly in two modes:

### Path Generation Mode

If called with just a type parameter, it creates a proxy where property access builds a JSON Pointer path string, accessible via `toString()`. This remains unchanged.

```typescript
import { createPatchProxy, JSONPatch } from '@dabble/patches';

interface Config {
  settings: { timeout: number };
}

const patch = new JSONPatch();
const configPath = createPatchProxy<Config>();

patch.replace(configPath.settings.timeout, 60);
// Path used: configPath.settings.timeout.toString() -> "/settings/timeout"

console.log(patch.ops[0].path); // /settings/timeout
```

### Automatic Patch Generation Mode

If called with a `target` object and a `JSONPatch` instance, it creates a proxy that automatically generates patch operations when modified (like within `createJSONPatch`).

```typescript
import { createPatchProxy, JSONPatch } from '@dabble/patches';

const data = { value: 1 };
const patch = new JSONPatch();
const proxy = createPatchProxy(data, patch);

proxy.value = 2; // Automatically calls patch.replace('/value', 2)

console.log(patch.ops); // [{ op: 'replace', path: '/value', value: 2 }]
```

## `applyPatch()` Function

(`src/json-patch/applyPatch.ts`)

Applies an array of patch operations to an object immutably.

```typescript
import { applyPatch, JSONPatchOp } from '@dabble/patches';

const doc = { name: 'A', count: 1 };
const ops: JSONPatchOp[] = [
  { op: 'replace', path: '/name', value: 'B' },
  { op: '@inc', path: '/count', value: 1 },
];

const newDoc = applyPatch(doc, ops);

console.log(newDoc); // { name: 'B', count: 2 }
console.log(doc); // { name: 'A', count: 1 } (original unchanged)
```

- Takes the `object`, `patches` array, optional `options`, and optional `custom` handlers.
- Returns `{ doc: T, errors: any[] }` where `doc` is the new state and `errors` is an array of any errors encountered during application.
- **Immutability:** Attempts to preserve object identity for parts of the tree that are not modified.
- **Options:**
  - `strict`: Throws on the first error.
  - `rigid`: Stops processing and returns the original object on the first error.
  - `createMissingObjects`: Allows `add`/`replace` to create necessary parent objects/arrays.
  - `atPath`: Applies all operations relative to a base path.

## Operation Handlers

(`src/json-patch/ops/`)

The library defines handlers for each standard JSON Patch operation and the included custom operations (e.g., `add`, `remove`, `replace`, `@inc`, `@bit`, `@txt`). Each operation type has a corresponding handler object that implements the following methods:

### Supported Operations

| Operation | Description                                                                                         |
| --------- | --------------------------------------------------------------------------------------------------- |
| `add`     | Adds a value at the specified path. For arrays, inserts at the given index.                         |
| `remove`  | Removes the value at the specified path. For arrays, removes the item at the given index.           |
| `replace` | Replaces the value at the specified path with a new value.                                          |
| `move`    | Moves a value from one path to another.                                                             |
| `copy`    | Copies a value from one path to another.                                                            |
| `test`    | Tests that a value at the specified path matches the provided value. Used for assertions.           |
| `@inc`    | Increments (or decrements) a number at the specified path by the given value.                       |
| `@bit`    | Sets or clears a specific bit in a bitmask at the specified path. Useful for compact boolean flags. |
| `@txt`    | Applies a rich text delta (e.g., Quill Delta) to a text field at the specified path.                |

### Handler Method Signatures

- **`apply(state: State, path: string, valueOrFrom: any): string | void;`**: Defines how the operation modifies the state when applied. For most operations, `valueOrFrom` is the value to apply; for `move` and `copy`, it is the `from` path. Returns a string error message on failure, or nothing on success.
- **`invert(state, op: CompactPatchOp, ...)`**: Generates an operation that reverses the effect of the original operation (used for undo functionality).
- **`transform(state, thisOp: CompactPatchOp, otherOps: CompactPatchOp[])`**: Modifies a list of concurrent operations (`otherOps`) given that this operation (`thisOp`) occurred first. This is crucial for Operational Transformation (OT) and collaborative editing.
- **`compose(state, value1, value2)`**: (Optional) Combines two consecutive operations of the same type on the same path into a single operation, if possible.

> **Note:** Implementing correct `transform` logic for each operation type is essential for the OT system to function reliably. Mistakes in transform handlers can lead to incorrect document state or loss of user intent in collaborative scenarios.

You can provide your own custom handlers when creating `JSONPatch` instances or using `applyPatch`.

See [`Operational Transformation`](./operational-transformation.md#operation-handlers) for more on their role in OT.
